import AsyncStorage from '@react-native-async-storage/async-storage';
import { CONFIG } from '../config/config';
import { coffeeOfflineManager } from '../offline';
const tipsData = require('../../content/dailyTips.json');

export interface Tip {
  id: number;
  text: string;
  date: string;
}

export const TIP_STORAGE_KEY = 'ai:dailyTip:last';
export const TIP_OFFLINE_CACHE_KEY_PREFIX = 'ai:dailyTip';
export const TIP_CACHE_TTL_HOURS = 24;

let scheduledRefreshHandle: ReturnType<typeof setTimeout> | null = null;

const tipList: Tip[] = tipsData as Tip[];
const OPENAI_API_KEY = CONFIG.OPENAI_API_KEY;
const isTestEnvironment = process.env.NODE_ENV === 'test';

/**
 * Builds a stable cache key for storing the tip content for a given date in offline storage.
 *
 * @param {string} date - ISO date string (YYYY-MM-DD) used to namespace the cached tip entry.
 * @returns {string} A cache key string scoped to the provided date.
 */
const buildOfflineCacheKey = (date: string) => `${TIP_OFFLINE_CACHE_KEY_PREFIX}:${date}`;

/**
 * Reads a cached tip for the provided date from AsyncStorage or offline cache.
 *
 * @param {string} date - ISO date string (YYYY-MM-DD) to fetch the cached tip for.
 * @returns {Promise<Tip | null>} A promise resolving with the cached tip or null when no cached entry exists.
 */
export const getTipFromCache = async (date: string): Promise<Tip | null> => {
  try {
    const offlineKey = buildOfflineCacheKey(date);
    const offlineCached = await coffeeOfflineManager.getItem<Tip>(offlineKey);
    if (offlineCached) {
      return offlineCached;
    }

    const stored = await AsyncStorage.getItem(TIP_STORAGE_KEY);
    if (!stored) {
      return null;
    }

    const parsed: Tip = JSON.parse(stored);
    if (parsed.date === date) {
      try {
        await coffeeOfflineManager.setItem(offlineKey, parsed, TIP_CACHE_TTL_HOURS, 4);
      } catch (error) {
        console.error('Error caching tip offline:', error);
      }
      return parsed;
    }

    return null;
  } catch (error) {
    console.error('Error reading cached tip:', error);
    return null;
  }
};

/**
 * Persists the given tip to AsyncStorage and the offline cache for future reads.
 *
 * @param {Tip} tip - Tip object to persist; must include `id`, `text`, and `date`.
 * @returns {Promise<void>} Promise that resolves when storage operations complete (errors are logged but not thrown).
 */
export const persistTip = async (tip: Tip): Promise<void> => {
  const offlineKey = buildOfflineCacheKey(tip.date);
  try {
    await AsyncStorage.setItem(TIP_STORAGE_KEY, JSON.stringify(tip));
  } catch (error) {
    console.error('Error saving last tip:', error);
  }

  try {
    await coffeeOfflineManager.setItem(offlineKey, tip, TIP_CACHE_TTL_HOURS, 4);
  } catch (error) {
    console.error('Error caching daily tip:', error);
  }
};

/**
 * Picks a deterministic tip for the specified date from the bundled static list.
 *
 * @param {string} date - ISO date string (YYYY-MM-DD) used to find or seed a fallback tip.
 * @returns {Tip} A tip matching the provided date or a fallback mapped from the day value.
 */
export const pickTipForDate = (date: string): Tip => {
  if (!tipList.length) {
    return {
      id: 0,
      text: 'Enjoy your brew!',
      date,
    };
  }

  const matched = tipList.find(tip => tip.date === date);
  if (matched) {
    return { ...matched, date };
  }

  const day = new Date(date).getDate();
  const fallback = tipList[day % tipList.length];
  return { ...fallback, date };
};

/**
 * Normalizes raw tip text by removing newlines and extraneous quotes.
 *
 * @param {string} raw - Tip body returned from AI or other sources.
 * @returns {string} Sanitized single-line tip text.
 */
const sanitizeTipText = (raw: string): string =>
  raw
    .replace(/[\r\n]+/g, ' ')
    .replace(/^['"„“”]+|['"„“”]+$/g, '')
    .replace(/\s+/g, ' ')
    .trim();

/**
 * Builds the Slovak language prompt sent to OpenAI for generating a daily tip.
 *
 * @param {string} date - ISO date string representing the day the tip is generated for.
 * @returns {string} Prepared prompt instructing the AI to deliver a concise barista tip.
 */
const buildTipPrompt = (date: string): string => {
  const formattedDate = new Date(date).toLocaleDateString('sk-SK', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  return `Dnes je ${formattedDate}. Priprav prosím jeden jedinečný baristický tip na kávu, ` +
    'maximálne v dvoch vetách. Tip musí byť praktický, konkrétny a napísaný po slovensky.';
};

/**
 * Generates a unique daily tip using OpenAI; skips generation in tests or when API key is missing.
 *
 * @param {string} date - ISO date string used to contextualize the AI prompt.
 * @returns {Promise<Tip | null>} A tip generated by AI or null when generation is unavailable or fails.
 */
const generateTipWithAI = async (date: string): Promise<Tip | null> => {
  if (!OPENAI_API_KEY || isTestEnvironment || typeof fetch !== 'function') {
    return null;
  }

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${OPENAI_API_KEY}`,
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        temperature: 0.5,
        max_tokens: 120,
        messages: [
          {
            role: 'system',
            content:
              'Si barista špecialista na domácu prípravu kávy. Ponúkni stručné, praktické tipy v slovenskom jazyku.',
          },
          { role: 'user', content: buildTipPrompt(date) },
        ],
      }),
    });

    if (!response.ok) {
      console.warn('DailyTipService: AI request failed with status', response.status);
      return null;
    }

    const data = await response.json();
    const tipText = sanitizeTipText(data?.choices?.[0]?.message?.content ?? '');
    if (!tipText) {
      return null;
    }

    return {
      id: Date.now(),
      text: tipText,
      date,
    };
  } catch (error) {
    console.error('DailyTipService: failed to generate AI tip', error);
    return null;
  }
};

/**
 * Fetches a tip for the current day, preferring cached data, then AI generation, and finally a static fallback.
 *
 * @param {Date} [now=new Date()] - Reference date to resolve the current tip for; defaults to system time.
 * @returns {Promise<Tip>} Resolved tip ready for display and subsequent caching.
 */
export const fetchDailyTip = async (now: Date = new Date()): Promise<Tip> => {
  const today = now.toISOString().slice(0, 10);
  const cached = await getTipFromCache(today);
  if (cached) {
    return cached;
  }

  const tip = (await generateTipWithAI(today)) ?? pickTipForDate(today);
  await persistTip(tip);
  return tip;
};

/**
 * Calculates the delay in milliseconds until the next midnight, used to schedule a refresh.
 *
 * @param {Date} [now=new Date()] - Reference point for calculating the remaining time until midnight.
 * @returns {number} Milliseconds between the provided time and the next midnight boundary.
 */
export const getNextRefreshDelay = (now: Date = new Date()): number => {
  const midnight = new Date(now);
  midnight.setHours(24, 0, 0, 0);
  return Math.max(midnight.getTime() - now.getTime(), 0);
};

/**
 * Schedules the provided refresh callback to run at the next midnight, clearing any previous timer.
 *
 * @param {() => Promise<unknown> | unknown} refresh - Callback invoked when the timer elapses; errors are logged.
 * @param {Date} [now=new Date()] - Optional reference date used to compute the delay until midnight.
 * @returns {ReturnType<typeof setTimeout>} Timeout handle that can be cleared to cancel the scheduled refresh.
 */
export const scheduleDailyTipRefresh = (
  refresh: () => Promise<unknown> | unknown,
  now: Date = new Date(),
): ReturnType<typeof setTimeout> => {
  const delay = getNextRefreshDelay(now);

  if (scheduledRefreshHandle) {
    clearTimeout(scheduledRefreshHandle);
  }

  scheduledRefreshHandle = setTimeout(() => {
    scheduledRefreshHandle = null;
    Promise.resolve()
      .then(() => refresh())
      .catch(error => {
        console.error('Error running scheduled daily tip refresh:', error);
      });
  }, delay);

  return scheduledRefreshHandle;
};

/**
 * Clears the scheduled daily tip refresh timer when present.
 */
export const clearScheduledDailyTipRefresh = () => {
  if (scheduledRefreshHandle) {
    clearTimeout(scheduledRefreshHandle);
    scheduledRefreshHandle = null;
  }
};

/**
 * Returns the currently scheduled refresh timeout handle if one exists.
 *
 * @returns {ReturnType<typeof setTimeout> | null} The active timeout reference or null when none is scheduled.
 */
export const getScheduledDailyTipRefreshHandle = () => scheduledRefreshHandle;
